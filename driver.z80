;; hUGETracker playback routine
;; Written by SuperDisk 2019

include "hardware.inc"
include "constants.inc"
include "debug_macros.inc"

add_a_to_r16: MACRO
    add a, \2
    ld \2, a
    adc a, \1
    sub \2
    ld \1, a
ENDM

;; TODO: See if there's a way to shave off a byte.
sub_from_r16: MACRO ;; (high, low, value)
    ld a, \2
    sub \3
    ld \2, a
    ld a, \1
    sbc a, 0
    ld \1, a
ENDM

add_a_to_hl: MACRO
    add_a_to_r16 h, l
ENDM

add_a_to_de: MACRO
    add_a_to_r16 d, e
ENDM

; Constants
STACK_SIZE EQU 20
;; Stack starts at $FFFE

PATTERN_LENGTH EQU 64
TICKS EQU 7

; $0000 - $003F: RST handlers.

SECTION "restarts", ROM0[$0000]
ret
REPT 7
    nop
ENDR
; $0008
ret
REPT 7
    nop
ENDR
; $0010
ret
REPT 7
    nop
ENDR
; $0018
ret
REPT 7
    nop
ENDR
; $0020
ret
REPT 7
    nop
ENDR
; $0028
ret
REPT 7
    nop
ENDR
; $0030
ret
REPT 7
    nop
ENDR
; $0038
ret
REPT 7
    nop
ENDR

; Interrupt addresses
SECTION "Vblank interrupt", ROM0[$0040]
    reti

SECTION "LCD controller status interrupt", ROM0[$0048]
    jp _dosound
    reti

SECTION "Timer overflow interrupt", ROM0[$0050]
    reti

SECTION "Serial transfer completion interrupt", ROM0[$0058]
    reti

SECTION "P10-P13 signal low edge interrupt", ROM0[$0060]
    reti

; Reserved stack space
SECTION "Stack", HRAM[$FFFE - STACK_SIZE]
    ds STACK_SIZE


; Control starts here, but there's more ROM header several bytes later, so the
; only thing we can really do is immediately jump to after the header
SECTION "init", ROM0[$0100]
    nop
    jp $0150

SECTION "romname", ROM0[$0134]
; $0134 - $013E: The title, in upper-case letters, followed by zeroes.
DB "HUGE"
DS 7 ; padding
; $013F - $0142: The manufacturer code. Empty for now
DS 4
DS 1
; $0144 - $0145: "New" Licensee Code, a two character name.
DB "NF"

SECTION "Song Data", ROM0
;; order_cnt is the number of orders times 2
order_cnt: db 2
order1: dw unreal ;; unreal ;; unreal;, lunawaves, lunawaves, unreal
order2: dw unreal_arps ;; empty, unreal, unreal, lunawaves
order3: dw empty, lunawaves, lunawaves, unreal
order4: dw empty, lunawaves, lunawaves, unreal

lunawaves:
include "lunawaves.inc"
unreal:
include "unreal.inc"
unreal_arps:
include "unreal_arps.inc"
empty:
rept 64
    db 90, 0, 0
endr
drums:
rept 16
    db 44, 0, 0
    db 90, 0, 0
    db 90, 0, 0
    db 90, 0, 0
endr
slideup:
  dn C4, 00, $000
rept 63
    dn 90, 00, $101
endr
arps:
rept 64
    dn C5, 00, $047
endr
updown:
    dn C4, 00, $105
rept 31
    dn 90, 00, $105
endr
rept 32
    dn 90, 00, $205
endr

SECTION "Playback variables", WRAM0
pattern1: dw
pattern2: dw
pattern3: dw
pattern4: dw

current_order: dw

;; Size of a channel in bytes
CHANNEL_SIZE EQU 8
;; Amount to be shifted in order to skip a channel.
CHANNEL_SIZE_EXPONENT EQU 3

channels:

;;;;;;;;;;;
;;Channel 1
;;;;;;;;;;;
channel1:
channel_period1: dw
toneporta_target1: dw
channel_note1: db
ds 3 ;; Just padding at the moment but may contain more stuff later

;;;;;;;;;;;
;;Channel 2
;;;;;;;;;;;
channel2:
channel_period2: dw
toneporta_target2: dw
channel_note2: db
ds 3

;;;;;;;;;;;
;;Channel 3
;;;;;;;;;;;
channel3:
channel_period3: dw
toneporta_target3: dw
channel_note3: db
ds 3

;;;;;;;;;;;
;;Channel 4
;;;;;;;;;;;
channel4:
channel_period4: dw
toneporta_target4: dw
channel_note4: db
ds 3

row: ds 1
tick: ds 1

; Initialization
SECTION "main", ROM0[$0150]
jp _init

_paint_tile:
    ld a, b
    ld [hl+], a
    ld a, c
    ld [hl+], a
    ret

_init:
    ; Set LCD palette for grayscale mode; yes, it has a palette
    ld a, %11100100
    ld [$FF00+$47], a

    ;; Fill with pattern
    ld hl, $8000
    ld bc, `10000000
    call _paint_tile
    ld bc, `01000000
    call _paint_tile
    ld bc, `00100000
    call _paint_tile
    ld bc, `00010000
    call _paint_tile
    ld bc, `00001000
    call _paint_tile
    ld bc, `00000100
    call _paint_tile
    ld bc, `00000010
    call _paint_tile
    ld bc, `00000001
    call _paint_tile

    ;; Load some wave data (or code) into _AUD3WAVERAM
    ld hl, $150 ;; note_table
_addr = _AUD3WAVERAM
    REPT 16
    ld a, [hl+]
    ldh [_addr], a
_addr = _addr + 1
    ENDR

    ;; Enable chanel 3
    ; ld a, $80
    ; ldh [rAUD3ENA], a
    ; ld a, $ff
    ; ldh [rAUD3LEN], a
    ; ld a, $20
    ; ldh [rAUD3LEVEL], a

    ; Enable sound globally
    ld a, $80
    ldh [rAUDENA], a
    ; Enable channel 1 in stereo
    ld a, $FF
    ldh [rAUDTERM], a
    ; Set volume
    ld a, $77
    ldh [rAUDVOL], a

    ld c, 0 ;; Current order index
    call _refresh_patterns

    ;; Enable the timer
    ld a, TACF_START | TACF_4KHZ
    ld [rTAC], a

    ;; Enable the HBlank interrupt on scanline 0
    ld a, [rSTAT]
    or a, STATF_LYC
    ld [rSTAT], a
    ld a, 0
    ld [rLYC], a

    ld a, IEF_LCDC ; IEF_VBLANK;  | IEF_LCDC ; IEF_HILO | IEF_TIMER
    ld [rIE], a
    ei

    jp _halt

_refresh_patterns:
;; Loads pattern registers with pointers to correct pattern based on
;; an order index

;; Call with c set to what order to load
load_pattern: MACRO
    ld hl, 0
    ld l, c
    ld de, \1
    add hl, de

    ld a, [hl+]
    ld [\2], a
    ld a, [hl+]
    ld [\2+1], a
ENDM
    load_pattern order1, pattern1
    load_pattern order2, pattern2
    load_pattern order3, pattern3
    load_pattern order4, pattern4
    ret

_lookup_note:
;; Call with:
;; Pattern pointer in DE

;; Stores note period value in HL
    ld a, [row]
    ld h, a
    ;; Multiply by 3 for the note value
    add h
    add h

    ld h, 0
    ld l, a
    inc l
    inc l
    add hl, de ; HL now points at the 3rd byte of the note
    ld a, [hl-]
    ld c, a
    ld a, [hl-]
    ld b, a

    ld a, [hl]
    ld [channel_note2], a

_try_convert_note:
    cp LAST_NOTE
    jp c, _convert_note
    ret

_convert_note:
    ;; Call with:
    ;; Note number in A
    ;; Stores note period value in HL

    add a, a ;; double it to get index into hi/lo table

    LD     H, 0
    LD     L, A
    LD     DE, note_table
    ADD    HL, DE
    LD     A, [HL+]
    ;; INC    HL
    LD     H, [HL]
    LD     L, A

    ccf ;; uh....?
    ret

strip_instrument: MACRO
    ld a, b
    and %00001111
    cp $3
ENDM

_update_channel:
;; Call with:
;; Channel in B
;; Note tone in DE

;; TODO: Turn this into a jump table? Or find some other way to optimize
    ld a, b

    cp 0
    jp z, _update_channel1
    cp 1
    jp z, _update_channel2
    cp 2
    jp z, _update_channel3
    cp 3
    jp z, _update_channel4

_update_channel1:
    ld a, e
    ldh [rAUD1LOW], a
    ld a, d
    ldh [rAUD1HIGH], a
    ret
_update_channel2:
    ld a, e
    ldh [rAUD2LOW], a
    ld a, d
    ldh [rAUD2HIGH], a
    ret
_update_channel3:

    ret
_update_channel4:

    ret

_playnote1:
;; Call with:
;; Note value in H and L
;; instrument + effect code in B

;; Play a note on channel 1 (square wave)
    strip_instrument

    jr nz, .no_toneporta
    ld a, h
    ld [toneporta_target1+1], a
    ld a, l
    ld [toneporta_target1], a
    ret

.no_toneporta:
    ld a, %10111111
    ld [rAUD1LEN], a

    ld a, %11110000
    ld [rAUD1ENV], a

    ld a, l
    ld [channel_period1], a
    ld [rAUD1LOW], a

    ld a, h
    ld [channel_period1+1], a
    or %00000000
    ld [rAUD1HIGH], a

    ret

_playnote2:
;; Call with:
;; Note value in H and L
;; instrument + effect code in B

;; Play a note on channel 2 (square wave)
    strip_instrument

    jr nz, .no_toneporta
    ld a, h
    ld [toneporta_target2+1], a
    ld a, l
    ld [toneporta_target2], a
    ret

.no_toneporta:
    ld a, %00111111 ; $10
    ld [rAUD2LEN], a
    ld a, %11110000
    ld [rAUD2ENV], a

    ld a, l
    ld [channel_period2], a
    ld [rAUD2LOW], a
    ld a, h
    ld [channel_period2+1], a
    or %00000000
    ld [rAUD2HIGH], a
    ret

_playnote3:
;; Call with:
;; Note value in H and L
;; instrument + effect code in B

;; Play a note on channel 3 (waveform)
    strip_instrument

    jr nz, .no_toneporta
    ld a, h
    ld [toneporta_target2+1], a
    ld a, l
    ld [toneporta_target2], a
    ret

.no_toneporta:
    ld a, l
    ld [channel_period3], a
    ld [rAUD3LOW], a
    ld a, h
    ld [channel_period3+1], a
    or %10000000
    ld [rAUD3HIGH], a
    ret

_playnote4:
;; Call with:
;; Note value in H and L
;; instrument + effect code in B

;; Play a "note" on channel 4 (noise)

    ld a, %00011111
    ld [rAUD4LEN], a
    ld a, %11110001
    ld [rAUD4ENV], a
    ld a, l; %01000100
    ld [rAUD4POLY], a
    ld a, %10000000
    ld [rAUD4GO], a

    ret

loadShort: MACRO
    ld a, [\1]
    ld \3, a
    ld a, [\1 + 1]
    ld \2, a
ENDM



_doeffect:
;; Call with:
;; B: instrument nibble + effect type nibble
;; C: effect parameters
;; E: channel

;; free: A, D, H, L

;; Strip the instrument bits off leaving only effect code
    ld a, b
    and %00001111
    ld b, a

    ;; Multiply by 3 to get offset into table
    ld a, b
    add a, b
    add a, b

    ld hl, .jump

    add a, l
    ld l, a
    adc a, h
    sub l
    ld h, a

    jp hl

.jump:
    ;; Jump table for effect
    jp fx_arpeggio                     ;0xy
    jp fx_porta_up                     ;1xy
    jp fx_porta_down                   ;2xy
    jp fx_toneporta                    ;3xy
    jp fx_no_op ;fx_vibrato            ;4xy
    jp fx_no_op ;fx_toneporta_volslide ;5xy
    jp fx_no_op ;fx_vibrato_volslide   ;6xy
    jp fx_no_op ;fx_tremolo            ;7xy
    jp fx_no_op ;fx_set_pan            ;8xy
    jp fx_no_op ;fx_set_duty           ;9xy
    jp fx_no_op ;fx_vol_slide          ;Axy
    jp fx_no_op ;fx_pos_jump           ;Bxy
    jp fx_no_op ;fx_set_volume         ;Cxy
    jp fx_no_op ;fx_pattern_break      ;Dxy
    jp fx_no_op ;fx_note_cut           ;Exy
    jp fx_no_op ;fx_set_speed          ;Fxy

setup_channel_pointer:
    ;; Call with:
    ;; Channel value in B
    ;; Offset in D
    ;; Returns value in HL

    ld a, b
    REPT CHANNEL_SIZE_EXPONENT
        sla a
    ENDR
    add d
    ld hl, channels
    add_a_to_hl
    ret

fx_no_op:
    ret

fx_arpeggio:
    ld b, e ;; so we have access to DE
    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ld d, 4
    call setup_channel_pointer

    ld a, [tick]
    dec a

    ;; Multiply by 2 to get offset into table
    add a

    ld d, [hl]

    ld hl, .arp_options
    add_a_to_hl
    jp hl

.arp_options:
    jr .set_arp1
    jr .set_arp2
    jr .reset_arp
    jr .set_arp1
    jr .set_arp2
.reset_arp:
    ld a, d
    jr .finish_skip_add
.set_arp2:
    ld a, c
    swap a
    jr .finish_arp
.set_arp1:
    ld a, c
.finish_arp:
    and %00001111
    add d
.finish_skip_add:
    call _convert_note
    ld d, h
    ld e, l
    jp _update_channel

fx_porta_up:
    ld b, e ;; so we have access to DE
    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ld d, 0
    call setup_channel_pointer

    ld a, [hl+]
    ld e, a
    ld d, [hl]

    ld a, c
    add_a_to_de

    ld a, d
    ld [hl-], a
    ld [hl], e

    jp _update_channel

;; TODO: Maybe merge with fx_porta_up, since they're so similar? Would need
;; to find a way to compare against effect code.
fx_porta_down:
    ld b, e ;; so we have access to DE
    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ld d, 0
    call setup_channel_pointer

    ld a, [hl+]
    ld e, a
    ld d, [hl]

    ld a, c
    sub_from_r16 d, e, c

    ld a, d
    ld [hl-], a
    ld [hl], e

    jp _update_channel


fx_toneporta:
    ld b, e ;; so we have access to DE
    ;; B: channel
    ;; C: effect parameters

    ;; free registers: A, D, E, H, L

    ;; TOOD: Optimize. This usage of the stack isn't great but IMO it's
    ;; better than using the stack hack which forces all effects to screw with
    ;; pushing and popping. Most effects won't need to do this.

    ld d, 0
    call setup_channel_pointer
    push hl

    ld a, [hl+]
    ld e, a
    ld a, [hl+]
    ld d, a

    ld a, [hl+]
    ld h, [hl]
    ld l, a

    ;; Comparing which direction to move the current value
    ;; TODO: Optimize this!!!!

    ;; Compare high byte
    ld a, h

    cp d
    jr c, .subtract ; target is less than the current period
    jr z, .high_byte_same
    jr .add
.high_byte_same:
    ld a, l
    cp e
    jr c, .subtract ; the target is less than the current period
    jr z, .done ; both nibbles are the same so no portamento
.add:
    ld a, c
    add a, e
    ld e, a
    adc a, d
    sub e
    ld d, a

    ld a, h
    cp d
    jr c, .set_exact
    ld a, l
    cp e
    jr c, .set_exact

    jr .done

.subtract:
    ld a, e
    sub c
    ld e, a

    ld a, d
    sbc a, 0
    ld d, a

    ld a, h
    cp d
    jr nc, .set_exact
    ld a, l
    cp e
    jr nc, .set_exact

    jr .done

.set_exact:
    ld d, h
    ld e, l
.done:
    pop hl
    ld a, e
    ld [hl+], a
    ld [hl], d

    jp _update_channel

_dosound:
    ld a, [tick]
    cp 0
    jr nz, .process_effects

    ;; We're on tick zero, so lookup and play the notes,
    ;; then return

    ;; For each call of _lookup_note we push an address to jump to,
    ;; and the procedure will discard its normal return value if it needs to
    ;; skip a note and use the new value instead.

    loadShort pattern1, d, e
    call _lookup_note
    jr nc, .after_note1
    call _playnote1

.after_note1:
    loadShort pattern2, d, e
    call _lookup_note
    jr nc, .after_note2
    call _playnote2

.after_note2:
    loadShort pattern3, d, e
    call _lookup_note
    jr nc, .after_note3
    call _playnote3

.after_note3:
    loadShort pattern4, d, e
    call _lookup_note
    jp nc, process_tick
    call _playnote4

    jp process_tick

.process_effects:
    ;; Only do effects if not on tick zero

    loadShort pattern1, d, e
    call _lookup_note

    ld a, c
    cp 0
    jp z, after_effect1

    ld e, 0
    call _doeffect

after_effect1:
    loadShort pattern2, d, e
    call _lookup_note

    ld a, c
    cp 0
    jp z, after_effect2

    ld e, 1
    call _doeffect

after_effect2:
    ; loadShort pattern3, d, e
    ; call _lookup_note
    ; ld e, 2
    ; call _doeffect

after_effect3:
    ; loadShort pattern4, d, e
    ; call _lookup_note
    ; ld e, 3
    ; call _doeffect

after_effect4:

process_tick:
    ld a, [tick]
    inc a

    cp TICKS
    jp z, _newrow

    ld [tick], a
    reti

_newrow:
    ;; Reset tick to 0
    ld a, 0
    ld [tick], a

    ;; Increment row.
    ld a, [row]
    inc a
    cp PATTERN_LENGTH
    jr nz, .noreset

    ;; Increment order and change loaded patterns
    ld a, [order_cnt]
    ld b, a
    ld a, [current_order]
    add a, 2
    cp b
    jr nz, .update_current_order
    ld a, 0
.update_current_order:
    ld [current_order], a
    ld c, a

    call _refresh_patterns

    ld a, 0
    ld [row], a
    reti

.noreset:
    ld [row], a

    reti

_halt:
    ; Do nothing, forever
    halt
    nop
    jr _halt

SECTION "Wave stuff", ROM0

SECTION "Note Table", ROM0
note_table:
include "music.inc"